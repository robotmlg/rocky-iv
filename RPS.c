#pragma config(Sensor, S4,     hand,           sensorI2CCustom)
#pragma config(Motor,  motorA,          wrist,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rfing,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          lfing,         tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Accelerometer Library
#include "hitechnic-accelerometer.h"

//Threshold for detecting a shake
#define SHAKE_TH 1200

//Range Macros
#define inRange(s,r,c) (c >= s - r && c <= s + r)//returns true if c is within range r of s
#define aboveRange(s,r,c) (c > s + r)//returns true if c is within range r of s
#define belowRange(s,r,c) (c < s - r)

//Wait for user to shake
#define WAIT_FOR_SHAKE()	HTACreadAllAxes(hand,x,y,z);\
							squaresum=(x/10)*(x/10)+(y/10)*(y/10)+(z/10)*(z/10);\
							while(squaresum<SHAKE_TH){\
								squaresum=(x/10)*(x/10)+(y/10)*(y/10)+(z/10)*(z/10);\
								HTACreadAllAxes(hand,x,y,z);}

//enum type for hand positions
enum{
	ROCK=0,
	PAPER=1,
	SCISSORS=2
};

//DEBUG FLAG
//The debug loops just display accel values and hand position on screen
//no movement
//#define DEBUG

//global to store the player's hand position
//written by readPlayer task, read by main task
//Are RobotC variables thread safe? Who knows
byte playerState=0;

task readPlayer();
int getPos();

task main(){
	int x=0,y=0,z=0;
	byte botState=0;
	long squaresum=0;
	string name[4]={"Rock","Paper","Scissors","Shoot!"};
	string verb[4]={"crushes","covers","cuts","ties"};
	string replay="play again";
	int win=0,lose=0,tie=0;
	byte temp=0;
	bool go=true;
	char winner='t';
	int games=1;
	string fname="RockyIV";
	setFriendlyName(fname);
	nVolume=kMaxVolumeLevel;
	eraseDisplay();
	srand(nSysTime);
	nNxtExitClicks=2;
	//slave the right finger to the left finger, because they always move together
	nSyncedMotors=synchBC;
	nSyncedTurnRatio=100;
	nMotorEncoder[wrist]=0;
	nMotorEncoder[rfing]=0;
#ifdef DEBUG
	//DEBUG LOOP: Display accelerometer values
	//SEE ALSO: second Debug Loop in readPlayer
	while(true){
		StartTask(readPlayer);
		HTACreadAllAxes(hand,x,y,z);
		nxtDisplayTextLine(0,"DEBUG MODE");
		nxtDisplayTextLine(1,"    x    y    z");
		nxtDisplayTextLine(2,"%5i%5i%5i",x,y,z);
	}
#endif
	//Display instructions
	nxtDisplayCenteredTextLine(0,"Setup:");
	nxtDisplayTextLine(1,"Place the sensor");
	nxtDisplayTextLine(2,"ring on your");
	nxtDisplayTextLine(3,"finger with the");
	nxtDisplayTextLine(4,"sensor on top of");
	nxtDisplayTextLine(5,"your hand.");
	nxtDisplayTextLine(6,"Shake your hand");
	nxtDisplayTextLine(7,"  to continue...");
	WAIT_FOR_SHAKE();
	PlaySound(soundUpwardTones);
	eraseDisplay();
	nxtDisplayCenteredTextLine(0,"How to play:");
	nxtDisplayTextLine(1,"Shake your hand ");
	nxtDisplayTextLine(2,"3 times to");
	nxtDisplayTextLine(3,"countdown. On");
	nxtDisplayTextLine(4,"the 4th shake, ");
	nxtDisplayTextLine(5,"form your hand");
	nxtDisplayTextLine(6,"into your shape.");
	nxtDisplayTextLine(7,"Shake to continue");
	wait1Msec(500);
	WAIT_FOR_SHAKE();
	PlaySound(soundUpwardTones);
	nxtDisplayCenteredTextLine(0,"Hand shapes:");
	nxtDisplayTextLine(1,"Rock: Sensor");
	nxtDisplayTextLine(2,"pointed sideways");
	nxtDisplayTextLine(3,"Paper: Hand");
	nxtDisplayTextLine(4,"   held flat");
	nxtDisplayTextLine(5,"Scissors:fingers");
	nxtDisplayTextLine(6," tilted upwards");
	nxtDisplayTextLine(7,"Shake to continue");
	wait1Msec(500);
	WAIT_FOR_SHAKE();
	PlaySound(soundUpwardTones);
	nxtDisplayCenteredTextLine(0,"Try it out:");
	nxtDisplayTextLine(1,"Move your hand");
	nxtDisplayTextLine(2,"into shapes to");
	nxtDisplayTextLine(3,"practice.");
	nxtDisplayTextLine(7,"Shake to continue");
	wait1Msec(500);
	//wait for shake while displaying hand position
	HTACreadAllAxes(hand,x,y,z);
	squaresum=(x/10)*(x/10)+(y/10)*(y/10)+(z/10)*(z/10);
	while(squaresum<SHAKE_TH+400){
		nxtDisplayCenteredBigTextLine(4,"%s",name[getPos()]);
		squaresum=(x/10)*(x/10)+(y/10)*(y/10)+(z/10)*(z/10);
		HTACreadAllAxes(hand,x,y,z);
	}
	PlaySound(soundUpwardTones);
	//MAIN LOOP
	while(go){
		eraseDisplay();
		//RESET HAND
		nxtDisplayCenteredBigTextLine(3,"READY");
		PlaySound(soundBeepBeep);
		//ROCK, PAPER, SCISSORS...
		int shakes=0;
		//swivel wrist to approximate shaking hand during count off
		while(shakes<3){
			nxtDisplayTextLine(7,"Shake %d times",4-shakes);
			WAIT_FOR_SHAKE();
			if(shakes==0)
				eraseDisplay();
			nxtDisplayCenteredBigTextLine(1+2*shakes,"%s,",name[shakes++]);
			PlayImmediateTone(440,5);
			//shake wrist on countdown
			nMotorEncoderTarget[wrist]=100;
			motor[wrist]=50;
			while(nMotorRunState[wrist]!=runStateIdle)
				wait1Msec(1);
			nMotorEncoderTarget[wrist]=-100;
			motor[wrist]=-50;
			while(nMotorRunState[wrist]!=runStateIdle)
				wait1Msec(1);
			motor[wrist]=0;
		}
		nxtDisplayTextLine(7,"Shake %d time",4-shakes);
		//SHOOT
		WAIT_FOR_SHAKE();
		PlayImmediateTone(880,5);
		eraseDisplay();
		nxtDisplayCenteredBigTextLine(3,"%s",name[shakes]);
		//read in the player's selection while moving the hand
		StartTask(readPlayer);
		//select hand position (randomly)
		temp=0;
		while(temp<3)
			temp=rand();
		botState=temp%3;
		nxtDisplayTextLine(7,"Please Wait.....");
		//move hand to new position
		//move the fingers first so that they don't scrape the ground
		//Extend fingers, if needed
		if(botState==PAPER || botState==SCISSORS){
			nMotorEncoderTarget[rfing]=-360;
			motor[rfing]=-100;
			while(nMotorRunState[rfing]!=runStateIdle)
				wait1Msec(1);
			motor[rfing]=0;
		}
		//rotate wrist 90 degrees, if needed
		if(botState==PAPER){
			nMotorEncoderTarget[wrist]=-987;
			motor[wrist]=-50;
			while(nMotorRunState[wrist]!=runStateIdle)
				wait1Msec(1);
			motor[wrist]=0;
		}
		//For ROCK, shake wrist, because the hand is already in rock position
		if(botState==ROCK){
			nMotorEncoderTarget[wrist]=100;
			motor[wrist]=50;
			while(nMotorRunState[wrist]!=runStateIdle)
				wait1Msec(1);
			nMotorEncoderTarget[wrist]=-100;
			motor[wrist]=-50;
			while(nMotorRunState[wrist]!=runStateIdle)
				wait1Msec(1);
			motor[wrist]=0;
		}
		eraseDisplay();
		//determine winner
		//First check the edge cases of ROCK and SCISSORS where the lower value wins
		//Then check the general case where the higher value wins
		//REMEBER: lose and win count the *player's* wins and losses
		if(playerState==SCISSORS && botState==ROCK){
			nxtDisplayCenteredBigTextLine(3,"I WIN!");
			PlaySound(soundDownwardTones);
			++lose;
			winner='b';
		}
		else if(playerState==ROCK && botState==SCISSORS){
			nxtDisplayCenteredBigTextLine(3,"YOU WIN!");
			PlaySound(soundUpwardTones);
			++win;
			winner='p';
		}
		else if(playerState>botState){
			nxtDisplayCenteredBigTextLine(3,"YOU WIN!");
			PlaySound(soundUpwardTones);
			++win;
			winner='p';
		}
		else if(playerState==botState){
			nxtDisplayCenteredBigTextLine(3,"TIE!");
			PlaySound(soundLowBuzz);
			++tie;
			winner='t';
		}
		else if(playerState<botState){
			nxtDisplayCenteredBigTextLine(3,"I WIN!");
			PlaySound(soundDownwardTones);
			++lose;
			winner='b';
		}
		//display the game summary with the correct verb
		//"crushes", "covers", "cuts", or "ties"
		switch(winner){
		case 'p':
			nxtDisplayCenteredTextLine(0,"Your %s",name[playerState]);
			nxtDisplayCenteredTextLine(1,"%s",verb[playerState]);
			nxtDisplayCenteredTextLine(2,"Rocky's %s",name[botState]);
			break;
		case 'b':
			nxtDisplayCenteredTextLine(0,"Rocky's %s",name[botState]);
			nxtDisplayCenteredTextLine(1,"%s",verb[botState]);
			nxtDisplayCenteredTextLine(2,"your %s",name[playerState]);
			break;
		case 't':
			nxtDisplayCenteredTextLine(0,"Your %s",name[playerState]);
			nxtDisplayCenteredTextLine(1,"%s",verb[3]);
			nxtDisplayCenteredTextLine(2,"Rocky's %s",name[botState]);
			break;
		}
		//SORE WINNER
		//If Rocky wins the Best of X match, end the program
		if(lose==games/2+1){
			PlaySound(soundFastUpwardTones);
			PlaySound(soundDownwardTones);
			PlaySound(soundFastUpwardTones);
			PlaySound(soundDownwardTones);
			//eraseDisplay();
			//nxtDisplayCenteredBigTextLine(3,"HAHA!");
			nxtDisplayCenteredBigTextLine(3,"I WIN!!!");
			nxtDisplayCenteredTextLine(5,"Best of %d",games);
			wait1Msec(3000);
			go=false;
			replay="exit";
		}
		//SORE LOSER
		//If Rocky loses the Best of X match, ask to go Best of X+2
		else if(win>games/2){
			nxtDisplayTextLine(6,"Go best of %d?",games+=2);
		}
		else{
			nxtDisplayTextLine(6,"(Best of %d)",games);
		}
		nxtDisplayTextLine(5,"Your Record:%i-%i-%i",win,lose,tie);
		nxtDisplayCenteredTextLine(7,"Shake to %s",replay);//"play again" or "exit"
		//nxtDisplayCenteredTextLine(7,"Gray to exit");
		WAIT_FOR_SHAKE();
		if(nNxtButtonPressed==kExitButton)
			go=false;
		eraseDisplay();
		//Reset the hand before exitting or playing again
		nxtDisplayCenteredBigTextLine(3,"RESETING;");
		nxtDisplayTextLine(7,"Please Wait.....");
		//Reset the wrist first so that the fingers don't scrape the ground
		while(nMotorEncoder[wrist]<0)
			motor[wrist]=50;
		motor[wrist]=0;
		while(nMotorEncoder[rfing]<0)
			motor[rfing]=100;
		motor[rfing]=0;

	}
}
/**
 * This task reads in the player's hand postion and writes it to the playerState variable
 * This is in a second task so that I can read the player and move the hand at the same time
 */
task readPlayer(){
#ifndef DEBUG
	//wait a bit before reading the player so their hand can stabilize
	wait1Msec(300);
#endif
	//GET PLAYER POSITION
	playerState=getPos();
#ifdef DEBUG
	//DEBUG: Display the selected shape on the screen
	string name[4]={"Rock","Paper","Scissors","Shoot!"};
	nxtDisplayCenteredBigTextLine(6,"%s",name[playerState]);
#endif
}

/**
 * This function reads in the player's hand position
 */
int getPos(){
	int x=0,y=0,z=0;
	HTACreadAllAxes(hand,x,y,z);
	//PAPER: Sensor level with ground, "standard" position
	if(inRange(200,60,z) && inRange(0,60,x))
		return PAPER;
	//ROCK: Like PAPER, rotated 90 degrees around x-axis
	else if(inRange(200,60,abs(y)) && inRange(0,60,x))
		return ROCK;
	//SCISSORS: all other positions, because it's hard to detect, as it's similar to rock
	else// if(inRange(120,40,x))
		return SCISSORS;
	return 0;
}
